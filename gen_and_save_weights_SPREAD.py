import nest
import nest.random
import numpy as np
from scipy import interpolate
from joblib import Parallel, delayed

class LineMaze():
    '''
    The line maze consists of a single linear track with a reward
    zone at each end. The track is oriented along the x-axis.
    '''
    def __init__(self,N,L = 40):
        self.N = N
        self.L = L

        self.x = np.linspace(0,L,N)
        self.y = np.zeros(N)

        # the left and right trajectories
        self.x_left = np.zeros(N)
        self.y_left = np.zeros(N)
        self.x_right = np.zeros(N)
        self.y_right = np.zeros(N)

        self.x_left = np.linspace(0,-L/2,N)
        self.y_left = np.zeros(N)

        self.x_right = np.linspace(0,L/2,N)
        self.y_right = np.zeros(N)

    def plot(self):
        plt.plot(self.x,self.y,'k.')
        plt.axis('equal')
        plt.show()


def gen_traj(maze,N_trials,p_correct,speed=20):
    '''Generate a set of trajectories through the maze. The
    trajectories are generated by a random walk with a probability
    of turning left or right at each step. The probability of
    turning left or right is determined by the p_correct parameter.

    Go from the stem to the reward zone, passing through each
    node on the maze

    Speed is the speed of the mouse in cm/s
    '''
    # generate a sequence of correct and incorrect trials
    correct = np.random.rand(N_trials) < p_correct

    # generate a sequence of left and right turns based on correct
    # trials being the OPPOSITE of the preceeding trial. Left is -1 and right is 1
    first_turn = np.random.rand() < 0.5
    turns = np.zeros(N_trials)
    turns[0] = -1 if first_turn else 1
    for i in range(1,N_trials):
        if correct[i]:
            turns[i] = -turns[i-1]
        else:
            turns[i] = turns[i-1]

    # assign turns to the outcomes
    x = []
    y = []

    for i in range(N_trials):
        if turns[i] == -1:
            x.append(maze.x_left)
            y.append(maze.y_left)
        else:
            x.append(maze.x_right)
            y.append(maze.y_right)
    # flatten the arrays
    x = np.array(x).flatten()
    y = np.array(y).flatten()

    # make an array of indexes where each trial starts in terms of the x array
    

    # calculate the time it takes to traverse the maze
    # get the physical distance tranvelled of one trial
    trial_length = np.sqrt((maze.x_left[0]-maze.x_left[-1])**2 + (maze.y_left[0]-maze.y_left[-1])**2)
    # the total time on the maze is the trial length divided by the speed 
    # times the number of trials
    t = np.linspace(0,N_trials*trial_length/speed,len(x))

    trial_starts = np.linspace(0,t-trial_length/speed,N_trials)
    trial_ends = np.linspace(trial_length/speed,max(t),N_trials)
    return t,x,y,trial_starts,trial_ends

def firing_place_cell_linear(t,x,center_x,L,sigma=7,rmax=20):
    '''Generate a place cell firing rate based on the position of the
    animal in the maze. The firing rate is a gaussian centered at the
    center_x position of the place cell. We ignore the center_y and y maze. 
    The firing rate is scaled by the distance from the center of the place field.

    center_x is the x position of the place field
    L is the maze length total
    sigma is the standard deviation of the gaussian

    There is also a theta-precession effect that is multiplied by the gaussian
    firing rate. This effect is a sinusoidal modulation of the firing rate with 
    a term for phase-precession.
    '''
    x_t = interpolate.interp1d(t,x,kind='linear',fill_value='extrapolate')
    # calculate the distance from the center of the place field
    # calculate the firing rate
    Q = sigma

    return lambda t: rmax*(np.exp(-((x_t(t)-center_x)**2)/(2*sigma**2)))*(1+np.cos(np.pi*7*t + (np.sign(center_x)*(x_t(t)-center_x)*np.pi/Q)))/2

def firing_ictal_spike(t,x,t_start_each,t_end_each,x_each,sigma,rmax=20):
    '''A focal ictal spike. The firing rate is a gaussian centered at x in x_each.'''

    x_t = interpolate.interp1d(t,x,kind='linear',fill_value='extrapolate')

    # place a guassian at each x_each which last only for that trial encoded by t_start_each and t_end_each
    # compute as the superposition of gaussians for each trial
    # calculate as an array, then interpolate to have it as a function of time
    for xc,ts,te in zip(x_each,t_start_each,t_end_each):
        r = np.zeros(len(t))
        r[(t >= ts) & (t <= te)] = rmax*np.exp(-((x_t(t[(t >= ts) & (t <= te)])-xc)**2)/(2*sigma**2))

    return interpolate.interp1d(t,r,kind='linear',fill_value='extrapolate')

def accept_reject_spike(t0,tmax,r,r_max=20):
    t_spike = []
    t_spike.append(t0)
    t = 0
    while t <= tmax:
        # draw spike at the max rate
        t = t + np.random.exponential(1/r_max)

        # with probability r(t) / r_max, keep the spike
        if np.random.rand() < r(t) / r_max:
            t_spike.append(t0 + t)

    return np.array(t_spike)

def gen_spike_train(t_sim,spread=False,STDP_ictal=False,seed=1234):

    # generate the maze
    L_maze = 300
    maze = LineMaze(3600,L=L_maze)

    t,x,y,trial_starts,trial_ends = gen_traj(maze,400,0.9,35)

    # Create CA3 and CA1 populations of parrot neurons
    nest.ResetKernel()
    nest.local_num_threads = 8
    #nest.SetKernelStatus({"resolution": 0.1})
    nest.rng_seed=seed

    N_pyr = 1250
    CA3_pyr = nest.Create("parrot_neuron", N_pyr)
    CA1_pyr = nest.Create("parrot_neuron", N_pyr)
    nest.SetStatus(CA3_pyr, {"tau_minus": 62.5})
    nest.SetStatus(CA1_pyr, {"tau_minus": 40})

    # make the clamped rates to assign to cells
    N_generators = int(np.floor(N_pyr*0.3))
    place_cell_spikes_CA3 = nest.Create("spike_train_injector", N_generators)
    place_cell_spikes_CA1 = nest.Create("spike_train_injector", N_generators)

    def assign_spikes_to_pf_generator(pf):
        r = firing_place_cell_linear(t,x,pf,L_maze,7)
        # draw spikes from the rate
        s_times = accept_reject_spike(0,t_sim,r)
        return s_times

    print("Connecting place cells to spikes...")
    # for each generator, draw a random place field on the maze and assign the rate generated
    # along a trajectory to the generator
    pf_CA3 = np.sort(np.random.uniform(-L_maze/2,L_maze/2,N_generators))
    pf_CA1 = np.sort(np.random.uniform(-L_maze/2,L_maze/2,N_generators))
    s_times = Parallel(n_jobs=8)(delayed(assign_spikes_to_pf_generator)(pf) for pf in np.concatenate((pf_CA3,pf_CA1)))
    
    s_times_CA3 = s_times[0:N_generators]
    s_times_CA1 = s_times[N_generators:]

    for s_time,generator in zip(s_times_CA3,place_cell_spikes_CA3):
        nest.SetStatus(generator, {"spike_times": 1000*s_time+0.1,"allow_offgrid_times": True,"precise_times": False})
    
    for s_time,generator in zip(s_times_CA1,place_cell_spikes_CA1):
        nest.SetStatus(generator, {"spike_times": 1000*s_time+0.1,"allow_offgrid_times": True,"precise_times": False})

    # generate the rest of the generators with random rates
    silent_cell_spikes = nest.Create("poisson_generator")
    nest.SetStatus(silent_cell_spikes, {"rate": 0.1})
    print("Done connecting place cells to spikes...")

    # connect the generators to the CA3 and CA1 populations
    nest.Connect(place_cell_spikes_CA3, CA3_pyr[0:N_generators], syn_spec={'weight': 1.0,'receptor_type':0}, conn_spec={'rule': 'one_to_one'})
    nest.Connect(silent_cell_spikes, CA3_pyr[N_generators:], syn_spec={'weight': 1.0,'receptor_type':0}, conn_spec={'rule': 'all_to_all'})
    nest.Connect(place_cell_spikes_CA1, CA1_pyr[0:N_generators], syn_spec={'weight': 1.0,'receptor_type':0}, conn_spec={'rule': 'one_to_one'})
    nest.Connect(silent_cell_spikes, CA1_pyr[N_generators:], syn_spec={'weight': 1.0,'receptor_type':0}, conn_spec={'rule': 'all_to_all'})

    # define a STDP synapse
    #weight_recorder = nest.Create("weight_recorder")

    # divide lambda by Wmax to scale everything to [0,1], which is then rescaled by Wmax in the synapse
    nest.CopyModel("stdp_synapse", "CA3_to_CA3",{"alpha": -1.0, "lambda": 0.08/40, "tau_plus": 62.5,"mu_plus":0,"mu_minus":0, "Wmax": 40.0})
    nest.CopyModel("stdp_synapse", "CA3_to_CA1",{"alpha": 0.4, "lambda": 0.8/40, "tau_plus": 20.0,"mu_plus":0,"mu_minus":0, "Wmax": 40.0})

    nest.Connect(CA3_pyr, CA3_pyr, syn_spec={'synapse_model':"CA3_to_CA3",'receptor_type':1,
                                            'weight':0.3*nest.random.lognormal(0,1)}, conn_spec={'rule': 'pairwise_bernoulli', 'p': 0.1,'allow_autapses': False})
    nest.Connect(CA3_pyr, CA1_pyr, syn_spec={'synapse_model':"CA3_to_CA1",'receptor_type':1,
                                            'weight':0.7*nest.random.lognormal(0,1)}, conn_spec={'rule': 'pairwise_bernoulli', 'p': 0.1,'allow_autapses': False})

    # connect the CA3 and CA1 populations with the STDP synapse
    if STDP_ictal:
        if spread:
            # create a reward zone ictal spike generator
            reward_zone_spikes = nest.Create("spike_generator")
            r_rz_right = firing_ictal_spike(t,x,trial_starts,trial_ends,np.random.randint(0,150,len(trial_starts)),4,2000)
            r_rz_left = firing_ictal_spike(t,x,trial_starts,trial_ends,-np.random.randint(0,150,len(trial_starts)),4,2000)
        else:
            # create a reward zone ictal spike generator
            reward_zone_spikes = nest.Create("spike_generator")
            r_rz_right = firing_ictal_spike(t,x,trial_starts,trial_ends,100*np.ones(len(trial_starts)),4,2000)
            r_rz_left = firing_ictal_spike(t,x,trial_starts,trial_ends,-100*np.ones(len(trial_starts)),4,2000)
        s_times_rz_right = accept_reject_spike(0,t_sim,r_rz_right)
        s_times_rz_left = accept_reject_spike(0,t_sim,r_rz_left)
        # concatenate the spike times
        s_times_rz = np.concatenate((s_times_rz_right,s_times_rz_left))
        #sort
        s_times_rz = np.sort(s_times_rz)

        # drive the reward zone generator
        nest.SetStatus(reward_zone_spikes, {"spike_times": 1000*s_times_rz+0.1,"allow_offgrid_times": True,"precise_times": False})

        # create parrot neuron for the spikes
        reward_zone_spikes_parrot = nest.Create("parrot_neuron",N_pyr)
        nest.Connect(reward_zone_spikes, reward_zone_spikes_parrot)
        nest.Connect(reward_zone_spikes_parrot, CA3_pyr, syn_spec={'weight': 1.0,'receptor_type':0,'synapse_model':'bernoulli_synapse','p_transmit':0.01},
                    conn_spec={'rule': 'one_to_one'}) 

    # monitor the spiking activity of the CA3 and CA1 populations
    spike_detector = nest.Create("spike_recorder")
    nest.Connect(CA3_pyr, spike_detector)
    nest.Connect(CA1_pyr, spike_detector)

    print("Simulating...")
    nest.Simulate(t_sim*1000)

    conn_CA3_to_CA3 = nest.GetConnections(CA3_pyr,CA3_pyr).get(['source','target','weight'])
    conn_CA3_to_CA1 = nest.GetConnections(CA3_pyr,CA1_pyr).get(['source','target','weight'])
    print("Done simulating")

    return conn_CA3_to_CA3,conn_CA3_to_CA1,pf_CA3,pf_CA1

N_reps = 10
t_sim = 600 # seconds

# store the results
conn_CA3_to_CA3_controls = []
conn_CA3_to_CA1_controls = []

conn_CA3_to_CA3_ictal = []
conn_CA3_to_CA1_ictal = []

conn_CA3_to_CA3_ictal_spread = []
conn_CA3_to_CA1_ictal_spread = []

all_pf_CA3_controls = []
all_pf_CA1_controls = []

all_pf_CA3_ictal = []
all_pf_CA1_ictal = []

all_pf_CA3_ictal_spread = []
all_pf_CA1_ictal_spread = []

for i in range(N_reps):
    print(i)
    conn_CA3_to_CA3,conn_CA3_to_CA1,pf_CA3,pf_CA1 = gen_spike_train(t_sim,STDP_ictal=False,seed=i+1000)
    conn_CA3_to_CA3_controls.append(conn_CA3_to_CA3)
    conn_CA3_to_CA1_controls.append(conn_CA3_to_CA1)
    all_pf_CA3_controls.append(pf_CA3)
    all_pf_CA1_controls.append(pf_CA1)
    
    conn_CA3_to_CA3,conn_CA3_to_CA1,pf_CA3,pf_CA1 = gen_spike_train(t_sim,STDP_ictal=True,seed=i+1000)
    conn_CA3_to_CA3_ictal.append(conn_CA3_to_CA3)
    conn_CA3_to_CA1_ictal.append(conn_CA3_to_CA1)
    all_pf_CA3_ictal.append(pf_CA3)
    all_pf_CA1_ictal.append(pf_CA1)

    conn_CA3_to_CA3,conn_CA3_to_CA1,pf_CA3,pf_CA1 = gen_spike_train(t_sim,STDP_ictal=True,spread=True,seed=i+1000)
    conn_CA3_to_CA3_ictal_spread.append(conn_CA3_to_CA3)
    conn_CA3_to_CA1_ictal_spread.append(conn_CA3_to_CA1)
    all_pf_CA3_ictal_spread.append(pf_CA3)
    all_pf_CA1_ictal_spread.append(pf_CA1)

np.savez('data/line_maze_data_spread.npz',conn_CA3_to_CA3_controls=conn_CA3_to_CA3_controls,conn_CA3_to_CA1_controls=conn_CA3_to_CA1_controls,
         conn_CA3_to_CA3_ictal=conn_CA3_to_CA3_ictal,conn_CA3_to_CA1_ictal=conn_CA3_to_CA1_ictal,
         conn_CA3_to_CA3_ictal_spread=conn_CA3_to_CA3_ictal_spread,conn_CA3_to_CA1_ictal_spread=conn_CA3_to_CA1_ictal_spread,
         all_pf_CA3_controls=all_pf_CA3_controls,all_pf_CA1_controls=all_pf_CA1_controls,
         all_pf_CA3_ictal=all_pf_CA3_ictal,all_pf_CA1_ictal=all_pf_CA1_ictal,
         all_pf_CA3_ictal_spread=all_pf_CA3_ictal_spread,all_pf_CA1_ictal_spread=all_pf_CA1_ictal_spread)