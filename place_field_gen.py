import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

# generate a Y maze
class YMaze():
    '''
    The Y mae consists of a stem arm and two arms that branch
    off with reward zone at each end. The Y is oriented along
    the y-axis, with two arms pointing out along the x-axis in
    opposite directions.
    '''
    def __init__(self,N,L = 40):
        self.N_arm = 2*N
        self.N_stem = N
        self.N = self.N_arm + self.N_stem

        self.L = L

        self.x = np.zeros(self.N)
        self.y = np.zeros(self.N)
        self.x[:self.N_stem] = np.linspace(0,0,self.N_stem)
        self.y[:self.N_stem] = np.linspace(0,self.L,self.N_stem)
        self.x[self.N_stem:] = np.linspace(-self.L/2,self.L/2,self.N_arm)
        self.y[self.N_stem:] = np.linspace(self.L,self.L,self.N_arm)

        # reward zone x and y
        self.x_rz = np.array([-self.L/2,self.L/2])
        self.y_rz = np.array([self.L,self.L])

        # the left and right trajectories
        self.x_left = np.zeros(self.N)
        self.y_left = np.zeros(self.N)
        self.x_right = np.zeros(self.N)
        self.y_right = np.zeros(self.N)

        self.x_left[:self.N_stem] = np.linspace(0,0,self.N_stem)
        self.y_left[:self.N_stem] = np.linspace(0,self.L,self.N_stem)
        self.x_left[self.N_stem:] = np.linspace(0,-self.L/2,self.N_arm)
        self.y_left[self.N_stem:] = np.linspace(self.L,self.L,self.N_arm)

        self.x_right[:self.N_stem] = np.linspace(0,0,self.N_stem)
        self.y_right[:self.N_stem] = np.linspace(0,self.L,self.N_stem)
        self.x_right[self.N_stem:] = np.linspace(0,self.L/2,self.N_arm)
        self.y_right[self.N_stem:] = np.linspace(self.L,self.L,self.N_arm)

    def plot(self):
        plt.plot(self.x,self.y,'k.')
        plt.plot(self.x_rz,self.y_rz,'r.')
        plt.axis('equal')
        plt.show()

class LineMaze():
    '''
    The line maze consists of a single linear track with a reward
    zone at each end. The track is oriented along the x-axis.
    '''
    def __init__(self,N,L = 40):
        self.N = N
        self.L = L

        self.x = np.linspace(0,L,N)
        self.y = np.zeros(N)

        # reward zone x and y
        self.x_rz = np.array([0,L])
        self.y_rz = np.array([0,0])

        # the left and right trajectories
        self.x_left = np.zeros(N)
        self.y_left = np.zeros(N)
        self.x_right = np.zeros(N)
        self.y_right = np.zeros(N)

        self.x_left = np.linspace(0,-L/2,N)
        self.y_left = np.zeros(N)

        self.x_right = np.linspace(0,L/2,N)
        self.y_right = np.zeros(N)

    def plot(self):
        plt.plot(self.x,self.y,'k.')
        plt.plot(self.x_rz,self.y_rz,'r.')
        plt.axis('equal')
        plt.show()


def gen_traj(maze,N_trials,p_correct,speed=20):
    '''Generate a set of trajectories through the maze. The
    trajectories are generated by a random walk with a probability
    of turning left or right at each step. The probability of
    turning left or right is determined by the p_correct parameter.

    Go from the stem to the reward zone, passing through each
    node on the maze

    Speed is the speed of the mouse in cm/s
    '''
    # generate a sequence of correct and incorrect trials
    correct = np.random.rand(N_trials) < p_correct

    # generate a sequence of left and right turns based on correct
    # trials being the OPPOSITE of the preceeding trial. Left is -1 and right is 1
    first_turn = np.random.rand() < 0.5
    turns = np.zeros(N_trials)
    turns[0] = -1 if first_turn else 1
    for i in range(1,N_trials):
        if correct[i]:
            turns[i] = -turns[i-1]
        else:
            turns[i] = turns[i-1]

    # assign turns to the outcomes
    x = []
    y = []

    for i in range(N_trials):
        if turns[i] == -1:
            x.append(maze.x_left)
            y.append(maze.y_left)
        else:
            x.append(maze.x_right)
            y.append(maze.y_right)
    # flatten the arrays
    x = np.array(x).flatten()
    y = np.array(y).flatten()

    # calculate the time it takes to traverse the maze
    # get the physical distance tranvelled of one trial
    trial_length = np.sqrt((maze.x_left[0]-maze.x_left[-1])**2 + (maze.y_left[0]-maze.y_left[-1])**2)
    # the total time on the maze is the trial length divided by the speed 
    # times the number of trials
    t = np.linspace(0,N_trials*trial_length/speed,len(x))
    return t,x,y

def firing_place_cell_linear(t,x,center_x,L,sigma=7,rmax=20):
    '''Generate a place cell firing rate based on the position of the
    animal in the maze. The firing rate is a gaussian centered at the
    center_x position of the place cell. We ignore the center_y and y maze. 
    The firing rate is scaled by the distance from the center of the place field.

    center_x is the x position of the place field
    L is the maze length total
    sigma is the standard deviation of the gaussian

    There is also a theta-precession effect that is multiplied by the gaussian
    firing rate. This effect is a sinusoidal modulation of the firing rate with 
    a term for phase-precession.
    '''
    x_t = interpolate.interp1d(t,x,kind='linear',fill_value='extrapolate')
    # calculate the distance from the center of the place field
    # calculate the firing rate
    return lambda t: rmax*(np.exp(-(np.sqrt((x_t(t)-center_x)**2))**2/(2*sigma**2)))*(1+np.cos(2*np.pi*7*t + (1/(2*2*sigma/L))*(x_t(t)-center_x)))/2