import nest
import numpy as np
import matplotlib.pyplot as plt

# generate a Y maze
class YMaze():
    '''The Y mae consists of a stem arm and two arms that branch
    off with reward zone at each end. The Y is oriented along
    the y-axis, with two arms pointing out along the x-axis in
    opposite directions.
    '''
    def __init__(self,N,L = 40):
        self.N_arm = 2*N
        self.N_stem = N
        self.N = self.N_arm + self.N_stem

        self.L = L

        self.x = np.zeros(self.N)
        self.y = np.zeros(self.N)
        self.x[:self.N_stem] = np.linspace(0,0,self.N_stem)
        self.y[:self.N_stem] = np.linspace(0,self.L,self.N_stem)
        self.x[self.N_stem:] = np.linspace(-self.L/2,self.L/2,self.N_arm)
        self.y[self.N_stem:] = np.linspace(self.L,self.L,self.N_arm)

        # reward zone x and y
        self.x_rz = np.array([-self.L/2,self.L/2])
        self.y_rz = np.array([self.L,self.L])

        # the left and right trajectories
        self.x_left = np.zeros(self.N)
        self.y_left = np.zeros(self.N)
        self.x_right = np.zeros(self.N)
        self.y_right = np.zeros(self.N)

        self.x_left[:self.N_stem] = np.linspace(0,0,self.N_stem)
        self.y_left[:self.N_stem] = np.linspace(0,self.L,self.N_stem)
        self.x_left[self.N_stem:] = np.linspace(0,-self.L/2,self.N_arm)
        self.y_left[self.N_stem:] = np.linspace(self.L,self.L,self.N_arm)

        self.x_right[:self.N_stem] = np.linspace(0,0,self.N_stem)
        self.y_right[:self.N_stem] = np.linspace(0,self.L,self.N_stem)
        self.x_right[self.N_stem:] = np.linspace(0,self.L/2,self.N_arm)
        self.y_right[self.N_stem:] = np.linspace(self.L,self.L,self.N_arm)

    def plot(self):
        plt.plot(self.x,self.y,'k.')
        plt.plot(self.x_rz,self.y_rz,'r.')
        plt.axis('equal')
        plt.show()

# generate place fields on maze


def gen_traj(maze,N_trials,p_correct):
    '''Generate a set of trajectories through the maze. The
    trajectories are generated by a random walk with a probability
    of turning left or right at each step. The probability of
    turning left or right is determined by the p_correct parameter.

    Go from the stem to the reward zone, passing through each
    node on the maze
    '''
    # generate a sequence of correct and incorrect trials
    correct = np.random.rand(N_trials) < p_correct

    # generate a sequence of left and right turns based on correct
    # trials being the OPPOSITE of the preceeding trial. Left is -1 and right is 1
    first_turn = np.random.rand() < 0.5
    turns = np.zeros(N_trials)
    turns[0] = -1 if first_turn else 1
    for i in range(1,N_trials):
        if correct[i]:
            turns[i] = -turns[i-1]
        else:
            turns[i] = turns[i-1]

    # assign turns to the outcomes
    x = []
    y = []

    for i in range(N_trials):
        if turns[i] == -1:
            x.append(maze.x_left)
            y.append(maze.y_left)
        else:
            x.append(maze.x_right)
            y.append(maze.y_right)
    # flatten the arrays
    x = np.array(x).flatten()
    y = np.array(y).flatten()
    return x,y    